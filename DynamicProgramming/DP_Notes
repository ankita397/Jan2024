BASE CASE : since recursion is started from n-1, our base case will always be for index 0
        1D / 2D DP :
                1. reach destination - i = 0 and j = 0
                2. reach boundaries on any side - i < 0 or j < 0
        DP on Subsequences:
                1. for target == 0 (target base case is written first)
                2. for index == 0
        Dp on Strings:
                1. for ind1 -ve for s1 => -ve means end of string s1
                2. for ind2 -ve for s2 => -ve means end of string s2


TC / SC :
1. Recursion 
  TC - Exponential(eg: 2^n) - TLE
  SC - Recursion stack space/ Path length
2. Memoization 
  TC - dp array size 
  SC - dp array size + Recursion stack space/ Path length
3. Tabulation
  TC - dp array size 
  SC - dp array size 
4. Space Optimization - f(n-1) encountered
  TC - dp array size 
  SC - Reduce space to 1D array size or O(1)

DP on Subsequences 
- Take | NotTake
- Always will have parameters - index and target
- f(n-1, target) - In the array till index n-1, does there exist a target
- Loops -
        ind - 1 to n-1
        target - 1 to sum

DP on Strings
- Types - Comparisons, Replaces, Edits
        - Match | notMatch
        - 2 indexes to represent pointers to 2 strings for comparison - ind1 for s1 and ind2 for s2
- Comparisons 
        - match - shrink both strings
        - Do comparison character wise
        - not match - need to be coded based on requirement
- Edits 
        - Same as comparison
        - match - shrink both strings
        - not match - need to be coded for all operations
- Replaces 
        - Same as comparison
        - match - shrink both strings
        - not match - need to be coded based on requirement

Tricks:
base case - tabulation to SO - dp[0][x] -> prev[x]
                             - remove dp[x][0] loop
