BASE CASE : since recursion is started from n-1, our base case will always be for index 0
        1D / 2D DP :
                1. reach destination - i = 0 and j = 0
                2. reach boundaries on any side - i < 0 or j < 0
        DP on Subsequences:
                1. for target == 0 (target base case is written first)
                2. for index == 0
        Dp on Strings:
                1. for ind1 -ve for s1 => -ve means end of string s1
                2. for ind2 -ve for s2 => -ve means end of string s2
                s1 gets exhausted or s2 gets exhausted
        DP on stocks:
                1. ind == n
                2. cap/txn == n(when required)
                3. base case return 0 - nor required for tabulation and SO


TC / SC :
1. Recursion 
  TC - Exponential(eg: 2^n) - TLE
  SC - Recursion stack space/ Path length
2. Memoization 
  TC - dp array size 
  SC - dp array size + Recursion stack space/ Path length
3. Tabulation
  TC - dp array size 
  SC - dp array size 
4. Space Optimization - f(n-1) encountered
  TC - dp array size 
  SC - Reduce space to 1D array size or O(1)

DP on Subsequences 
- Take | NotTake
- Always will have parameters - index and target
- f(n-1, target) - In the array till index n-1, does there exist a target
- Loops -
        ind - 1 to n-1
        target - 1 to sum

DP on Strings
- Types - Comparisons, Replaces, Edits
        - Match | notMatch
        - 2 indexes to represent pointers to 2 strings for comparison - ind1 for s1 and ind2 for s2
- Comparisons 
        - match - shrink both strings
        - Do comparison character wise
        - not match - need to be coded based on requirement
- Edits 
        - Same as comparison
        - match - shrink both strings
        - not match - need to be coded for all operations
- Replaces 
        - Same as comparison
        - match - shrink both strings
        - not match - need to be coded based on requirement

Tricks:
- tabulation to SO
        base case - dp[0][x] -> prev[x]
                  - remove dp[x][0] loop from and assign for curr[0] inside 1st loop - eg: dp[i][0] = i --> curr[0] = i
- For SO, imagine 0th row to be prev and 1st row to be curr
- if loop 'ind' loop starts from n-1 and ind+1 is used later, then dp size should be dp[n+1][x] - otherwise out of bounds
- if ind+2 is used, base -> ind >= n - otherwise out of bounds
- Be mindful of out of bounds conditions(in base as well as loops)
